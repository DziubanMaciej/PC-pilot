// This file is autogenerated, do not try to change it manually
package com.paijan.pcpilot.communication

import android.util.Log
import java.net.InetAddress
import java.nio.ByteBuffer
import java.util.Arrays

fun ByteBuffer.putPreamble(): ByteBuffer {
    return this
            .put('P'.toByte())
            .put('C'.toByte())
            .put('P'.toByte())
            .put('I'.toByte())
            .put('L'.toByte())
            .put('O'.toByte())
            .put('T'.toByte())
}

abstract class Message protected constructor(protected val bytes: ByteArray) {
    protected fun getFloat(index: Int): Float {
        return ByteBuffer.wrap(bytes).getFloat(index)
    }

    protected fun getByte(index: Int): Byte {
        return bytes[index]
    }

    protected fun getBytes(from: Int, to: Int): ByteArray {
        return Arrays.copyOfRange(bytes, from, to)
    }

    protected fun getInt(index: Int): Int {
        return ByteBuffer.wrap(bytes).getInt(index)
    }

    protected fun getInetAddress(index: Int): InetAddress {
        val address = Arrays.copyOfRange(bytes, index, index + 4)
        return InetAddress.getByAddress(address)
    }
}

class ServerMessage private constructor(bytes: ByteArray) : Message(bytes) {
    enum class Type(val value: Byte) {
        ConnectionRequest(0),
        KeepAlive(1),
        MoveCursor(2),
        LeftPress(3),
        LeftRelease(4);

        companion object {
            fun fromValue(value: Byte): Type? {
                return values().find { it.value == value }
            }
        }
    }

    companion object {
        const val SIZE = 16

        fun fromBytes(bytes: ByteArray, length: Int): List<ServerMessage> {
            val result = mutableListOf<ServerMessage>()
            for (i in 0 until length step SIZE) {
                val messageBytes = Arrays.copyOfRange(bytes, i, i + SIZE)
                if (!validatePreamble(messageBytes)) continue

                val message = ServerMessage(messageBytes)
                if (message.getType() != null) {
                    result.add(message)
                } else {
                    Log.w("Message", "Unknown message, ignoring")
                }
            }
            return result
        }

        private fun validatePreamble(bytes: ByteArray): Boolean {
            return bytes[0] == 'P'.toByte()
                && bytes[1] == 'C'.toByte()
                && bytes[2] == 'P'.toByte()
                && bytes[3] == 'I'.toByte()
                && bytes[4] == 'L'.toByte()
                && bytes[5] == 'O'.toByte()
                && bytes[6] == 'T'.toByte()
        }

        fun toBytes(messages: List<ServerMessage>): ByteArray {
            val totalSize = messages.size * SIZE
            val result = ByteArray(totalSize)

            var index = 0
            for (message in messages) {
                System.arraycopy(message.bytes, 0, result, index, SIZE)
                index += SIZE
            }
            return result
        }

        fun createMessageConnectionRequest(): ServerMessage {
            val bytes = ByteBuffer.allocate(SIZE)
                .putPreamble()
                .put(Type.ConnectionRequest.value)
                .array()
            return ServerMessage(bytes)
        }

        fun createMessageKeepAlive(): ServerMessage {
            val bytes = ByteBuffer.allocate(SIZE)
                .putPreamble()
                .put(Type.KeepAlive.value)
                .array()
            return ServerMessage(bytes)
        }

        fun createMessageMoveCursor(x: Float, y: Float): ServerMessage {
            val bytes = ByteBuffer.allocate(SIZE)
                .putPreamble()
                .put(Type.MoveCursor.value)
                .putFloat(x)
                .putFloat(y)
                .array()
            return ServerMessage(bytes)
        }

        fun createMessageLeftPress(): ServerMessage {
            val bytes = ByteBuffer.allocate(SIZE)
                .putPreamble()
                .put(Type.LeftPress.value)
                .array()
            return ServerMessage(bytes)
        }

        fun createMessageLeftRelease(): ServerMessage {
            val bytes = ByteBuffer.allocate(SIZE)
                .putPreamble()
                .put(Type.LeftRelease.value)
                .array()
            return ServerMessage(bytes)
        }
    }

    fun getType(): Type? {
        return Type.fromValue(getByte(7))
    }

    fun getMessageMoveCursorX(): Float {
        return getFloat(8)
    }

    fun getMessageMoveCursorY(): Float {
        return getFloat(12)
    }
}

class ClientMessage private constructor(bytes: ByteArray) : Message(bytes) {
    enum class Type(val value: Byte) {
        ConnectionAccept(0),
        KeepAlive(1);

        companion object {
            fun fromValue(value: Byte): Type? {
                return values().find { it.value == value }
            }
        }
    }

    companion object {
        const val SIZE = 8

        fun fromBytes(bytes: ByteArray, length: Int): List<ClientMessage> {
            val result = mutableListOf<ClientMessage>()
            for (i in 0 until length step SIZE) {
                val messageBytes = Arrays.copyOfRange(bytes, i, i + SIZE)
                if (!validatePreamble(messageBytes)) continue

                val message = ClientMessage(messageBytes)
                if (message.getType() != null) {
                    result.add(message)
                } else {
                    Log.w("Message", "Unknown message, ignoring")
                }
            }
            return result
        }

        private fun validatePreamble(bytes: ByteArray): Boolean {
            return bytes[0] == 'P'.toByte()
                && bytes[1] == 'C'.toByte()
                && bytes[2] == 'P'.toByte()
                && bytes[3] == 'I'.toByte()
                && bytes[4] == 'L'.toByte()
                && bytes[5] == 'O'.toByte()
                && bytes[6] == 'T'.toByte()
        }

        fun toBytes(messages: List<ClientMessage>): ByteArray {
            val totalSize = messages.size * SIZE
            val result = ByteArray(totalSize)

            var index = 0
            for (message in messages) {
                System.arraycopy(message.bytes, 0, result, index, SIZE)
                index += SIZE
            }
            return result
        }

        fun createMessageConnectionAccept(): ClientMessage {
            val bytes = ByteBuffer.allocate(SIZE)
                .putPreamble()
                .put(Type.ConnectionAccept.value)
                .array()
            return ClientMessage(bytes)
        }

        fun createMessageKeepAlive(): ClientMessage {
            val bytes = ByteBuffer.allocate(SIZE)
                .putPreamble()
                .put(Type.KeepAlive.value)
                .array()
            return ClientMessage(bytes)
        }
    }

    fun getType(): Type? {
        return Type.fromValue(getByte(7))
    }
}
