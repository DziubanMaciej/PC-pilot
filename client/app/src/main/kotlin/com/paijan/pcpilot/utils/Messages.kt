// This file is autogenerated, do not try to change it manually
package com.paijan.pcpilot.utils

import android.util.Log
import java.net.InetAddress
import java.net.InetSocketAddress
import java.nio.ByteBuffer
import java.nio.ByteOrder
import java.util.Arrays

fun ByteBuffer.putPreamble(): ByteBuffer {
    return this
            .put('P'.toByte())
            .put('C'.toByte())
            .put('P'.toByte())
            .put('I'.toByte())
            .put('L'.toByte())
            .put('O'.toByte())
            .put('T'.toByte())
}

abstract class Message protected constructor(protected val bytes: ByteArray) {
    protected fun getFloat(index: Int): Float {
        return ByteBuffer.wrap(bytes).getFloat(index)
    }

    protected fun getByte(index: Int): Byte {
        return bytes[index]
    }

    protected fun getBytes(from: Int, to: Int): ByteArray {
        return Arrays.copyOfRange(bytes, from, to)
    }

    protected fun getInt(index: Int): Int {
        return ByteBuffer.wrap(bytes).getInt(index)
    }

    protected fun getInetAddress(index: Int): InetAddress {
        val address = Arrays.copyOfRange(bytes, index, index + 4)
        return InetAddress.getByAddress(address)
    }
}

class ServerMessage private constructor(bytes: ByteArray, val address: InetSocketAddress) : Message(bytes) {
    enum class Type(val value: Byte) {
        ConnectionRequest(0),
        KeepAlive(1),
        Disconnect(2),
        MoveCursor(3),
        LeftPress(4),
        LeftRelease(5),
        RightPress(6),
        RightRelease(7);

        companion object {
            fun fromValue(value: Byte): Type? {
                return values().find { it.value == value }
            }
        }
    }

    companion object {
        const val SIZE = 16

        fun fromBytes(bytes: ByteArray, length: Int, address: InetSocketAddress): List<ServerMessage> {
            val result = mutableListOf<ServerMessage>()
            for (i in 0 until length step SIZE) {
                val messageBytes = Arrays.copyOfRange(bytes, i, i + SIZE)
                if (!validatePreamble(messageBytes)) continue

                val message = ServerMessage(messageBytes, address)
                if (message.getType() != null) {
                    result.add(message)
                } else {
                    Log.w("Message", "Unknown message, ignoring")
                }
            }
            return result
        }

        private fun validatePreamble(bytes: ByteArray): Boolean {
            return bytes[0] == 'P'.toByte()
                && bytes[1] == 'C'.toByte()
                && bytes[2] == 'P'.toByte()
                && bytes[3] == 'I'.toByte()
                && bytes[4] == 'L'.toByte()
                && bytes[5] == 'O'.toByte()
                && bytes[6] == 'T'.toByte()
        }

        fun toBytes(messages: List<ServerMessage>): ByteArray {
            val totalSize = messages.size * SIZE
            val result = ByteArray(totalSize)

            var index = 0
            for (message in messages) {
                System.arraycopy(message.bytes, 0, result, index, SIZE)
                index += SIZE
            }
            return result
        }

        fun createMessageConnectionRequest(address: InetSocketAddress): ServerMessage {
            val bytes = ByteBuffer.allocate(SIZE)
                    .order(ByteOrder.LITTLE_ENDIAN)
                    .putPreamble()
                    .put(Type.ConnectionRequest.value)
                    .array()
            return ServerMessage(bytes, address)
        }

        fun createMessageKeepAlive(address: InetSocketAddress): ServerMessage {
            val bytes = ByteBuffer.allocate(SIZE)
                    .order(ByteOrder.LITTLE_ENDIAN)
                    .putPreamble()
                    .put(Type.KeepAlive.value)
                    .array()
            return ServerMessage(bytes, address)
        }

        fun createMessageDisconnect(address: InetSocketAddress): ServerMessage {
            val bytes = ByteBuffer.allocate(SIZE)
                    .order(ByteOrder.LITTLE_ENDIAN)
                    .putPreamble()
                    .put(Type.Disconnect.value)
                    .array()
            return ServerMessage(bytes, address)
        }

        fun createMessageMoveCursor(address: InetSocketAddress, x: Float, y: Float): ServerMessage {
            val bytes = ByteBuffer.allocate(SIZE)
                    .order(ByteOrder.LITTLE_ENDIAN)
                    .putPreamble()
                    .put(Type.MoveCursor.value)
                    .putFloat(x)
                    .putFloat(y)
                    .array()
            return ServerMessage(bytes, address)
        }

        fun createMessageLeftPress(address: InetSocketAddress): ServerMessage {
            val bytes = ByteBuffer.allocate(SIZE)
                    .order(ByteOrder.LITTLE_ENDIAN)
                    .putPreamble()
                    .put(Type.LeftPress.value)
                    .array()
            return ServerMessage(bytes, address)
        }

        fun createMessageLeftRelease(address: InetSocketAddress): ServerMessage {
            val bytes = ByteBuffer.allocate(SIZE)
                    .order(ByteOrder.LITTLE_ENDIAN)
                    .putPreamble()
                    .put(Type.LeftRelease.value)
                    .array()
            return ServerMessage(bytes, address)
        }

        fun createMessageRightPress(address: InetSocketAddress): ServerMessage {
            val bytes = ByteBuffer.allocate(SIZE)
                    .order(ByteOrder.LITTLE_ENDIAN)
                    .putPreamble()
                    .put(Type.RightPress.value)
                    .array()
            return ServerMessage(bytes, address)
        }

        fun createMessageRightRelease(address: InetSocketAddress): ServerMessage {
            val bytes = ByteBuffer.allocate(SIZE)
                    .order(ByteOrder.LITTLE_ENDIAN)
                    .putPreamble()
                    .put(Type.RightRelease.value)
                    .array()
            return ServerMessage(bytes, address)
        }
    }

    fun getType(): Type? {
        return Type.fromValue(getByte(7))
    }

    fun getMessageMoveCursorX(): Float {
        return getFloat(8)
    }

    fun getMessageMoveCursorY(): Float {
        return getFloat(12)
    }
}

class ClientMessage private constructor(bytes: ByteArray, val address: InetSocketAddress) : Message(bytes) {
    enum class Type(val value: Byte) {
        ConnectionAccept(0),
        KeepAlive(1);

        companion object {
            fun fromValue(value: Byte): Type? {
                return values().find { it.value == value }
            }
        }
    }

    companion object {
        const val SIZE = 8

        fun fromBytes(bytes: ByteArray, length: Int, address: InetSocketAddress): List<ClientMessage> {
            val result = mutableListOf<ClientMessage>()
            for (i in 0 until length step SIZE) {
                val messageBytes = Arrays.copyOfRange(bytes, i, i + SIZE)
                if (!validatePreamble(messageBytes)) continue

                val message = ClientMessage(messageBytes, address)
                if (message.getType() != null) {
                    result.add(message)
                } else {
                    Log.w("Message", "Unknown message, ignoring")
                }
            }
            return result
        }

        private fun validatePreamble(bytes: ByteArray): Boolean {
            return bytes[0] == 'P'.toByte()
                && bytes[1] == 'C'.toByte()
                && bytes[2] == 'P'.toByte()
                && bytes[3] == 'I'.toByte()
                && bytes[4] == 'L'.toByte()
                && bytes[5] == 'O'.toByte()
                && bytes[6] == 'T'.toByte()
        }

        fun toBytes(messages: List<ClientMessage>): ByteArray {
            val totalSize = messages.size * SIZE
            val result = ByteArray(totalSize)

            var index = 0
            for (message in messages) {
                System.arraycopy(message.bytes, 0, result, index, SIZE)
                index += SIZE
            }
            return result
        }

        fun createMessageConnectionAccept(address: InetSocketAddress): ClientMessage {
            val bytes = ByteBuffer.allocate(SIZE)
                    .order(ByteOrder.LITTLE_ENDIAN)
                    .putPreamble()
                    .put(Type.ConnectionAccept.value)
                    .array()
            return ClientMessage(bytes, address)
        }

        fun createMessageKeepAlive(address: InetSocketAddress): ClientMessage {
            val bytes = ByteBuffer.allocate(SIZE)
                    .order(ByteOrder.LITTLE_ENDIAN)
                    .putPreamble()
                    .put(Type.KeepAlive.value)
                    .array()
            return ClientMessage(bytes, address)
        }
    }

    fun getType(): Type? {
        return Type.fromValue(getByte(7))
    }
}
