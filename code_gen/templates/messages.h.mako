<%! import utils.definitions as definitions%>\
// This file is autogenerated, do not try to change it manually
#pragma once

#include "Communication/InetAddress.h"
#include <vector>

using Byte = unsigned char;

template <typename DerivingClass, unsigned int SIZE>
class Message {
public:
    static void fromBytes(const std::vector<Byte> &bytes, const InetAddress &address, std::vector<DerivingClass> &result) {
        result.clear();

        for (auto i = 0u; i < bytes.size() - SIZE + 1; i += SIZE) {
            if (!validatePreamble(bytes.data(), i)) continue;

            DerivingClass message{ address, bytes.data() + i };
            if (message.validateType()) {
                result.push_back(std::move(message));
            }
        }
    }

    static void toBytes(const std::vector<DerivingClass> &messages, std::vector<Byte> &result) {
        const auto totalSize = messages.size() * SIZE;
        result.resize(totalSize);

        auto index = 0u;
        for (const auto &message : messages) {
            std::memcpy(result.data() + index, message.bytes, SIZE);
            index += SIZE;
        }
    }

    Message(Message&&) = default;
    Message& operator=(Message&&) = default;
protected:
    Byte bytes[SIZE];
    Message() {}
    Message(const Byte *bytes) {
        std::memcpy(this->bytes, bytes, SIZE);
    }
    Message(Message&) = delete;
    Message& operator=(Message&) = delete;

    template <typename T, int offset>
    T getField() {
        static_assert(offset + sizeof(T) - 1 < SIZE, "invalid offset");
        T result;
        std::memcpy(&result, this->bytes + offset, sizeof(T));
        return result;
    }

    template <typename T, int offset>
    DerivingClass& setField(T field) {
        static_assert(offset + sizeof(T) - 1 < SIZE, "invalid offset");
        std::memcpy(this->bytes + offset, &field, sizeof(T));
        return *static_cast<DerivingClass*>(this);
    }

    DerivingClass& setPreamble() {
        static const std::string field = "${definitions.preamble_value}";
        std::memcpy(this->bytes + 0, &field.front(), 7);
        return *static_cast<DerivingClass*>(this);
    }

    static bool validatePreamble(const Byte* bytes, size_t offset) {
        static const char* PREAMBLE = "${definitions.preamble_value}";
        return std::memcmp(bytes, PREAMBLE, ${len(definitions.preamble_value)}) == 0;
    }
};
%for message_class in message_classes:



class ${message_class.name} : public Message<${message_class.name}, ${utils.get_largest_message_size(message_class)}> {
    friend class Message<${message_class.name}, ${utils.get_largest_message_size(message_class)}>;
    ${message_class.name}(const InetAddress &address) : address(address) {}
    ${message_class.name}(const InetAddress &address, const Byte* bytes) : Message(bytes), address(address) {}
public:
    ${message_class.name}() = default;
    ${message_class.name}(${message_class.name}&&) = default;
    ${message_class.name}& operator=(${message_class.name}&&) = default;

    InetAddress address;

    enum class Type : Byte {
    % for index, message in enumerate(message_class.messages):
        ${message.name} = ${index},
    % endfor
        ErrorType = ${len(message_class.messages)}
    };

    Type getType() {
        return static_cast<Type>(getField<Byte, ${len(definitions.preamble_value)}>());
    }

    bool validateType() {
        return getType() < Type::ErrorType;
    }
    % for message in message_class.messages:

    // --- --- --- ${message.name}
    static ${message_class.name} createMessage${message.name}(${utils.get_args_list(message.fields)}) {
        return std::move(${message_class.name}(address)
            .setPreamble()
            .setField<Byte, ${len(definitions.preamble_value)}>(static_cast<Byte>(Type::${message.name}))
        % for field in message.fields:
        % if not utils.is_fixed_field(field):
            .setField<${field.type.name_cpp}, ${field.offset}>(${field.name})
        % endif
        % endfor
        );
    }
    %for field in message.fields:
    % if not utils.is_fixed_field(field):
    ${field.type.name_cpp} getMessage${message.name}${field.name.title()}() {
        return getField<${field.type.name_cpp}, ${field.offset}>();
    }
    % endif
    % endfor
    % endfor
};
%endfor
