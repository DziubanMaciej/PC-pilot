<%! import utils.template_utils as utils %>\
<%! import utils.definitions as definitions%>\
// This file is autogenerated, do not try to change it manually
package com.paijan.pcpilot.communication

import android.util.Log
import java.net.InetAddress
import java.net.InetSocketAddress
import java.nio.ByteBuffer
import java.util.Arrays

fun ByteBuffer.putPreamble(): ByteBuffer {
    return this
    % for character in definitions.preamble_value:
            .put('${character}'.toByte())
    % endfor
}

abstract class Message protected constructor(protected val bytes: ByteArray) {
    protected fun getFloat(index: Int): Float {
        return ByteBuffer.wrap(bytes).getFloat(index)
    }

    protected fun getByte(index: Int): Byte {
        return bytes[index]
    }

    protected fun getBytes(from: Int, to: Int): ByteArray {
        return Arrays.copyOfRange(bytes, from, to)
    }

    protected fun getInt(index: Int): Int {
        return ByteBuffer.wrap(bytes).getInt(index)
    }

    protected fun getInetAddress(index: Int): InetAddress {
        val address = Arrays.copyOfRange(bytes, index, index + 4)
        return InetAddress.getByAddress(address)
    }
}
%for message_class in message_classes:

class ${message_class.name} private constructor(bytes: ByteArray${utils.get_sender_address_ctor_field_kt(message_class, endpoint)}) : Message(bytes) {
    enum class Type(val value: Byte) {
    % for index, message in enumerate(message_class.messages):
        ${message.name}(${index})${utils.trailing_sign(index + 1 == len(message_class.messages), ',', ';')}
    % endfor

        companion object {
            fun fromValue(value: Byte): Type? {
                return values().find { it.value == value }
            }
        }
    }

    companion object {
        const val SIZE = ${utils.get_largest_message_size(message_class)}

        fun fromBytes(bytes: ByteArray, length: Int${utils.get_sender_address_method_field_kt(message_class, endpoint)}): List<${message_class.name}> {
            val result = mutableListOf<${message_class.name}>()
            for (i in 0 until length step SIZE) {
                val messageBytes = Arrays.copyOfRange(bytes, i, i + SIZE)
                if (!validatePreamble(messageBytes)) continue

                val message = ${message_class.name}(messageBytes${utils.get_sender_address_value(message_class, endpoint, 'senderAddress')})
                if (message.getType() != null) {
                    result.add(message)
                } else {
                    Log.w("Message", "Unknown message, ignoring")
                }
            }
            return result
        }

        private fun validatePreamble(bytes: ByteArray): Boolean {
            return bytes[0] == '${definitions.preamble_value[0]}'.toByte()
            % for i, character in enumerate(definitions.preamble_value[1:]):
                && bytes[${i+1}] == '${definitions.preamble_value[i+1]}'.toByte()
            % endfor
        }

        fun toBytes(messages: List<${message_class.name}>): ByteArray {
            val totalSize = messages.size * SIZE
            val result = ByteArray(totalSize)

            var index = 0
            for (message in messages) {
                System.arraycopy(message.bytes, 0, result, index, SIZE)
                index += SIZE
            }
            return result
        }
        % for message in message_class.messages:

        fun createMessage${message.name}(${utils.get_args_list_kt(message.fields)}): ${message_class.name} {
            val bytes = ByteBuffer.allocate(SIZE)
                ${utils.get_put_call_kt('Preamble', None)}
                ${utils.get_put_call_kt('Byte', 'Type.{}.value'.format(message.name))}
                % for field in message.fields:
                % if not utils.is_fixed_field(field):
                ${utils.get_put_call_kt(field.type, field.name)}
                % endif
                % endfor
                .array()
            return ${message_class.name}(bytes${utils.get_sender_address_value(message_class, endpoint, None)})
        }
        % endfor
    }

    fun getType(): Type? {
        return Type.fromValue(getByte(${len(definitions.preamble_value)}))
    }
    % for message in message_class.messages:
    % for field in message.fields:
    % if not utils.is_fixed_field(field):

    fun getMessage${message.name}${field.name.title()}(): ${utils.translate_type_name_kt(field.type)} {
        return get${utils.translate_type_name_kt(field.type)}(${field.offset})
    }
    % endif
    % endfor
    % endfor
}
%endfor