<%! import utils.template_utils as utils %>\
// This file is autogenerated, do not try to change it manually
package com.paijan.pcpilot.communication

import android.util.Log
import java.net.InetAddress
import java.nio.ByteBuffer
import java.util.Arrays

abstract class Message protected constructor(private val bytes: ByteArray) {
    protected fun getFloat(index: Int): Float {
        return ByteBuffer.wrap(bytes).getFloat(index)
    }

    protected fun getByte(index: Int): Byte {
        return bytes[index]
    }

    protected fun getBytes(from: Int, to: Int): ByteArray {
        return Arrays.copyOfRange(bytes, from, to)
    }

    protected fun getInt(index: Int): Int {
        return ByteBuffer.wrap(bytes).getInt(index)
    }

    protected fun getInetAddress(index: Int): InetAddress {
        val address = Arrays.copyOfRange(bytes, index, index + 4)
        return InetAddress.getByAddress(address)
    }
}
%for message_class in message_classes:

class ${message_class.name} private constructor(bytes: ByteArray) : Message(bytes) {
    enum class Type(val value: Byte) {
    % for index, message in enumerate(message_class.messages):
        ${message.name}(${index})${utils.trailing_sign(index + 1 == len(message_class.messages), ',', ';')}
    % endfor

        companion object {
            fun fromValue(value: Byte): Type? {
                return values().find { it.value == value }
            }
        }
    }

    companion object {
        const val SIZE = ${utils.get_largest_message_size(message_class)}

        fun fromBytes(bytes: ByteArray, length: Int): List<${message_class.name}> {
            val result = mutableListOf<${message_class.name}>()
            for (i in 0 until length step SIZE) {
                val messageBytes = Arrays.copyOfRange(bytes, i, i + SIZE)
                val message = ${message_class.name}(messageBytes)
                if (message.getType() != null) {
                    result.add(message)
                } else {
                    Log.w("Message", "Unknown message, ignoring")
                }
            }
            return result
        }
        % for message in message_class.messages:

        fun createMessage${message.name}(${utils.get_args_list_kt(message.fields)}): ${message_class.name} {
            val bytes = ByteBuffer.allocate(SIZE)
                ${utils.get_put_call_kt('Byte', 'Type.{}.value'.format(message.name))}
                % for field in message.fields:
                % if not utils.is_type_field(field):
                ${utils.get_put_call_kt(field.type, field.name)}
                % endif
                % endfor
                .array()
            return ${message_class.name}(bytes)
        }
        % endfor
    }

    fun getType(): Type? {
        return Type.fromValue(getByte(0))
    }
    % for message in message_class.messages:
    % for field in message.fields:
    % if not utils.is_type_field(field):

    fun getMessage${message.name}${field.name.title()}(): ${utils.translate_type_name_kt(field.type)} {
        return get${utils.translate_type_name_kt(field.type)}(${field.offset})
    }
    % endif
    % endfor
    % endfor
}
%endfor